1.抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。找到匹配的处理程序之后，他就任务异常将得到处理，然后就不再寻找。

2.查找异常的时候并不要求跑出的异常同处理程序锁声明的异常完全匹配。派生类的对象也可以匹配基类的处理程序。

3.异常处理办法：
-在知道该如何处理的情况下才捕获异常
-解决问题并重新调用产生异常的方法
-进行少许修补，然后绕过异常产生的地方继续执行
-用别的数据进行计算时，以代替方法预计会返回的异常

4.只能在代码中忽略runtimeexception（及其子类）类型的异常，其他类型异常处理都是由编译器强制实施的。runtimeException代表的是：无法预料的错误，比如从你控制范围之外引来的null,
应该在代码中检查错误（比如数组越界，除数为0）。

5.当java中的异常不允许会带异常抛出的地点时,可以采用这样的策略：
吧try块放在循环里，就建立了一个“程序必须执行之前必须达到”的条件，还可以加入一个static类型的计数器或者别的装置，是循环不在放弃以前能够执行一定的次数。

6.当涉及到break和continue语句的时候，finally依旧会得到执行

7.当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的异常

8.异常类分两大类型：Error类代表了编译和系统的错误，不允许捕获；Exception类代表了标准Java库方法所激发的异常。Exception类还包含运行异常类Runtime_Exception和非运行异常类Non_RuntimeException这两个直接的子类。

运行异常类对应于编译错误，它是指Java程序在运行时产生的由解释器引发的各种异常。运行异常可能出现在任何地方，且出现频率很高，因此为了避免巨大的系统资源开销，编译器不对异常进行检查。所以Java语言中的运行异常不一定被捕获。出现运行错误往往表示代码有错误，如：算数异常（如被0除）、下标异常（如数组越界）等。

非运行异常时Non_RuntimeException类及其子类的实例，又称为可检测异常。Java编译器利用分析方法或构造方法中可能产生的结果来检测Java程序中是否含有检测异常的处理程序，对于每个可能的可检测异常，方法或构造方法的throws子句必须列出该异常对应的类。在Java的标准包java.lang java.util 和 java.net 中定义的异常都是非运行异常。
